#!/usr/bin/php
<?php
# Copyright (c) 2012 Colin Williams / University of Southampton
# License: GPL

# This file is part of Event Feed Aggregator.

# Event Feed Aggregator is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Event Feed Aggregator is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Event Feed Aggregator.  If not, see <http://www.gnu.org/licenses/>.

require('../etc/config.php');
require($diary_config["path"].'/lib/xml.php');
require($diary_config["path"].'/lib/utils.php');

// Disable reporting of deprecated features.
error_reporting(E_ALL ^ E_DEPRECATED);

declare(ticks = 1);

// Setup alarm function that is called when SIGALRM is raised.
pcntl_signal(SIGALRM, "alarm", false);

// Setup namespace prefixes.
$ns['event']	= 'http://purl.org/NET/c4dm/event.owl#';
$ns['rdfs']	= 'http://www.w3.org/2000/01/rdf-schema#';
$ns['rdf']	= 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
$ns['tl']	= 'http://purl.org/NET/c4dm/timeline.owl#';
$ns['geo']	= 'http://www.w3.org/2003/01/geo/wgs84_pos#';
$ns['foaf']	= 'http://xmlns.com/foaf/0.1/';
$ns['dcterms']	= 'http://purl.org/dc/terms/';
$ns['diary']	= 'http://id.southampton.ac.uk/ns/diary/';
$ns['deri']	= 'http://vocab.deri.ie/rooms#';
$ns['prog']	= 'http://purl.org/prog/';
$ns['prov']	= 'http://purl.org/void/provenance/ns/';
$ns['to']	= 'http://www.w3.org/2006/time#';

// Try opening the config file.
if (($handle = fopen($diary_config["path"]."/etc/config.csv", "r")) !== FALSE) {
	// Get column names from the first line of the CSV file.
	$c = array_flip(fgetcsv($handle, 1000, ","));

	// For each remaining line...
	while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
		// Generate the options array.
		$options = array();
		foreach($c as $key => $id)
		{
			if($key != 'Script')
			{
				$options[preg_replace('/[^A-Za-z]/', '', $key)] = @$data[$id];
			}
		}

		// Process a single feed.
		processFeed($data[$c['Script']], $options);
	}
	// Close the config file.
	fclose($handle);
}

/**
 * Process a single feed.
 * 
 * @param	string	$script		The name of the script to use to process the feed.
 * @param	array	$options	The options that should be passed to the script.
 */
function processFeed($script, $options)
{
	$id = $options['FeedID'];
	printInfo();

	// Check that the script parameter is set.
	if($script == "")
	{
		printInfo("Unable to process $id.  No script set.");
		return;
	}
	printInfo("Processing $id");
	printInfo("Script: $script");

	if($options['TimeLimit'] != "") {
		$limit = $options['TimeLimit'];
	} else {
		$limit = 30;
	}

	if(preg_match('/^[A-Za-z0-9]+$/', $script))
	{
		// Fork the process into parent and child.
		$pid = pcntl_fork();
		if ($pid == -1) {
			printInfo("Could not fork", true);
			die();
		} else if ($pid) {
			// This is the parent process.
			runParent($pid, $limit, $options);
		} else {
			// This is the child process.
			$code = runChild($script, $options);
			// Exit, to ensure that this child goes no further
			exit($code);
		}
	}
}

/**
 * Run the parent process.
 *
 * @param	int	$pid		The process ID of the child process.
 * @param	int	$limit		The time limit (in seconds) that the child process should be allowed to run for.
 * @param	array	$options	The options that were passed to the child process.
 */
function runParent($pid, $limit = 30, $options) {
	global $gpid;
	global $gfeedid;
	// Store the PID of the child.
	$gpid = $pid;
	// Store the FeedID of the child.
	$gfeedid = $options['FeedID'];
	// set an alarm, to limit the execution time.
	pcntl_alarm($limit);
	// Wait for the child to return.
	$cid = pcntl_waitpid($pid, $status);
	// Check whether the child returned correctly.
	if($cid > 0) {
		if(pcntl_wifexited($status) && pcntl_wexitstatus($status) > 0)
		{
			printInfo("Script for $gfeedid exited with status ".pcntl_wexitstatus($status), true);
		}
		if(pcntl_wifsignaled($status))
		{
			printInfo("Script for $gfeedid signalled with signal ".pcntl_wtermsig($status), true);
		}
		if(pcntl_wifstopped($status))
		{
			printInfo("Script for $gfeedid stopped with signal ".pcntl_wstopsig($status), true);
		}
	}
}

/**
 * Run the child process.
 *
 * @param	string	$script		The script to run.
 * @param	array	$options	The options to pass to the script.
 */
function runChild($script, $options) {
	global $fh;
	global $diary_config;

	$procstarttime = time();

	// Convert the options array into XML form.
	$optionsxml = generate_xml_from_array($options, 'options');
	$optionsxml = '<options>'.$optionsxml.'</options>';

	// Generate the command, with the options XML as a command line argument.
	$cmd = $diary_config["path"].'/bin/scripts/'.$script.' -o '.escapeshellarg($optionsxml);
	printInfo($cmd);

	// Execute the command.
	exec($cmd, $output);

	// Convert the response XML into an object.
	$xml = simplexml_load_string(implode("\n", $output));

	// Check that the response is valid.
	if($xml == null)
	{
		printInfo("Bad response from ".$options['FeedID']." script: ".implode("", $output), true);
		logError("Bad response from script: ".implode("", $output), $options['FeedID']);
		return 1;
	}

	// Check the number of events.
	$eventcount = count($xml->event);
	if($eventcount == 0)
	{
		printInfo("No events found while processing ".$options['FeedID']);
		logError(strtoupper("No events found"), $options['FeedID']);
	}
	else if($eventcount == 1)
	{
		printInfo("1 event found while processing ".$options['FeedID']);
	}
	else
	{
		printInfo("$eventcount events found while processing ".$options['FeedID']);
	}

	$safeid = preg_replace('/[^A-Za-z0-9]/', '', $options['FeedID']);
	// Open a file to write the output (as RDF triples) to.
	$fh = fopen($diary_config["path"].'/var/output/'.$safeid, 'w');

	tripleA('http://id.southampton.ac.uk/diary/', ns('prog', 'Programme'));
		
	$feeduri = 'http://id.southampton.ac.uk/diary/'.$safeid;
	tripleA($feeduri, ns('prog', 'Programme'));

	// Output provenance information.
	$feedprovuri = $feeduri.'#provenance-'.date('U', $procstarttime);
	tripleA($feedprovuri, ns('prov', 'ProvenanceEvent'));

	tripleU($feedprovuri, ns('to', 'hasBeginning'), date('c', $procstarttime), "http://www.w3.org/2001/XMLSchema#dateTime");

	tripleU($feedprovuri, ns('prov', 'processType'), $feeduri.'#process');

	tripleU($feedprovuri, ns('prov', 'sourceDataset'), $options['FeedURL']);
	tripleU($feedprovuri, ns('prov', 'resultingDataset'), $feeduri);

	// If the XML has events...
	if($xml->event != null)
	{
		foreach($xml->event as $event)
		{
			// Process the event.
			processEvent($event, $options['FeedID']);
			$eventuri = 'http://id.southampton.ac.uk/event/'.md5($event->link);
			tripleU($feeduri, ns('prog', 'has_event'), $eventuri);
			tripleU('http://id.southampton.ac.uk/diary/', ns('prog', 'has_event'), $eventuri);

			$eventprovuri = $eventuri.'#provenance-'.date('U', $procstarttime);
			tripleA($eventprovuri, ns('prov', 'ProvenanceEvent'));

			//tripleU($eventprovuri, ns('to', 'hasBeginning'), date('c', $procstarttime), "http://www.w3.org/2001/XMLSchema#dateTime");

			tripleU($eventprovuri, ns('prov', 'processType'), $eventuri.'#process');

			if(!is_null($event->sourceDocuments) && !is_null($event->sourceDocuments->event)) {
				foreach($event->sourceDocuments->event as $sds) {
					tripleU($eventprovuri, ns('prov', 'sourceDataset'), $sds);
				}
			}
			tripleU($eventprovuri, ns('prov', 'sourceDataset'), $options['FeedURL']);
			tripleU($eventprovuri, ns('prov', 'resultingDataset'), $eventuri);
		}
	}
	tripleU($feedprovuri, ns('to', 'hasEnd'), date('c'), "http://www.w3.org/2001/XMLSchema#dateTime");

	// Close the file.
	fclose($fh);
	return 0;
}

/**
 * Print an information message (possibly only if in verbose mode).
 *
 * @param	string	$string	The string to print.
 * @param	bool	$force	True if the string should be printed even when not in verbose mode.
 */
function printInfo($string="", $force=false) {
	if($force || getopt('v')) {
		echo $string."\n";
	}
}

/**
 * Alarm function.
 *
 * @param	int	$signo	The signal that caused the alarm to be raised.
 */
function alarm($signo) {
	global $gpid;
	global $gfeedid;
	if($gpid > 0)
	{
		printInfo("Going to terminate script for $gfeedid", true);
		if(posix_kill($gpid, SIGKILL))
		{
			printInfo("Script for $gfeedid killed successfully", true);
		}
		else
		{
			printInfo("Failed to kill script for $gfeedid", true);
			die();
		}
	}
}

/**
 * Write a line to the output file.
 *
 * @param	string	$string	The string to write to the file.
 */
function writeToFile($string) {
	global $fh;
	fwrite($fh, $string."\n");
}

/**
 * Output an RDF triple with a URI object.
 *
 * @param	string	$subject	The URI of the subject.
 * @param	string	$predicate	The URI of the predicate.
 * @param	string	$object		The URI of the object.
 */
function tripleU($subject, $predicate, $object) {
	writeToFile("<$subject> <$predicate> <$object> .");
}

/**
 * Output an RDF triple with a literal object.
 *
 * @param	string	$subject	The URI of the subject.
 * @param	string	$predicate	The URI of the predicate.
 * @param	string	$object		The literal value of the object.
 */
function tripleL($subject, $predicate, $object, $object_type = null ) {
	if( isset( $object_type ) ) { 
		writeToFile("<$subject> <$predicate> \"".str_replace(array("\n", "\"", "\\"), array('\n', '\"', '\\'), trim($object, " "))."\"^^<$object_type> .");
	}
	writeToFile("<$subject> <$predicate> \"".str_replace(array("\n", "\"", "\\"), array('\n', '\"', '\\'), trim($object, " "))."\" .");
}

/**
 * Output an RDF triple defining the type of an entity.
 *
 * @param	string	$subject	The URI of the subject.
 * @param	string	$type		The type of the subject.
 */
function tripleA($subject, $type) {
	tripleU($subject, ns("rdf", "type"), $type);
}

/**
 * Expand a URI given using a prefix.
 *
 * @param	string	$prefix		The prefix identifier.
 * @param	string	$e		The entity name.
 */
function ns($prefix, $e) {
	global $ns;
	if(isset($ns[$prefix])) {
		return $ns[$prefix].$e;
	} else {
		return $prefix.":".$e;
	}
}

/**
 * Process a single event, outputting RDF triples to the relevant file.
 * 
 * @param	object	$event	The event to process.
 * @param	string	$feedid	The ID of the feed.
 */
function processEvent($event, $feedid)
{
	if(trim($event->link) == "")
	{
		printInfo("Event with name ".str_replace("\n", "", $event->title)." has no link.");
		logError("Event with name ".str_replace("\n", "", $event->title)." has no link.", $feedid);
		return;
	}
	$uri = 'http://id.southampton.ac.uk/event/'.md5($event->link);

	// Process basic info.
	tripleA($uri, ns("event", "Event"));
	tripleL($uri, ns("rdfs", "label"), str_replace("\n", "", $event->title));
	tripleL($uri, ns("dcterms", "description"), $event->desc);
	tripleU($uri, ns("foaf", "homepage"), $event->link);

	// Process event type.
	if(isset($event->type) && $event->type != "")
	{
		tripleU($uri, ns("diary", "event-type"), ns("diary", $event->type));
	}

	// Process host.
	if(isset($event->host) && $event->host != "")
	{
		tripleU($uri, ns("event", "agent"), $event->host);
	}

	// Process tags.
	if(isset($event->tags))
	{
		foreach($event->tags->event as $tag)
		{
			tripleU($uri, ns("diary", "tag"), ns("diary", $tag));
		}
	}

	// Process dates.
	$i = 0;
	foreach($event->date->event as $d)
	{
		$i++;
		// The event has a 'from' datetime.
		if(isset($d->from))
		{
			tripleU($uri, ns("event", "time"), "$uri#time-$i");
			tripleA("$uri#time-$i", ns("tl", "Interval"));
			tripleL("$uri#time-$i", ns("tl", "start"), $d->from, "http://www.w3.org/2001/XMLSchema#dateTime" );
			// The event also has a 'to' datetime.
			if(isset($d->to))
			{
				tripleL("$uri#time-$i", ns("tl", "end"), $d->to, "http://www.w3.org/2001/XMLSchema#dateTime");
			}
		}
		// The event has a simple 'date' (with no time).
		elseif(isset($d->date))
		{
			tripleU($uri, ns("event", "time"), "$uri#time-$i");
			tripleA("$uri#time-$i", ns("tl", "Interval"));
			tripleL("$uri#time-$i", ns("tl", "at"), substr($d->date, 0, 10), "http://www.w3.org/2001/XMLSchema#date");
		}
	}

	// Process venue.
	if(isset($event->venuelink))
	{
		tripleU($uri, ns("event", "place"), $event->venuelink);
		$roomprefix = "http://id.southampton.ac.uk/room/";
		if(substr($event->venuelink, 0, strlen($roomprefix)) == $roomprefix)
		{
			$roomid = substr($event->venuelink, strlen($roomprefix));
			$roomid = explode('-', $roomid);
			tripleA($event->venuelink, ns("deri", "Room"));
			tripleL($event->venuelink, ns("rdfs", "label"), implode(" / ", $roomid));
			tripleU($event->venuelink, "http://data.ordnancesurvey.co.uk/ontology/spatialrelations/within", "http://id.southampton.ac.uk/building/".$roomid[0]);
		}
	}

	// TODO: Currently, venues with a defined URI (which may be at the campus level) also have a separate
	//       'SpatialThing' entity created.  This is in order to make the full venue details available.
	//	 If this behaviour is undesired, change this 'if' to an 'else if'.
	if(isset($event->venue))
	{
		tripleU($uri, ns("event", "place"), "$uri#place");
		tripleA("$uri#place", ns("geo", "SpatialThing"));
		tripleL("$uri#place", ns("rdfs", "label"), $event->venue);
	}

	// Process speaker.
	if(isset($event->speaker))
	{
		tripleU($uri, ns("event", "agent"), "$uri#speaker");
		tripleA("$uri#speaker", ns("foaf", "Person"));
		tripleL("$uri#speaker", ns("foaf", "name"), $event->speaker);
		if(isset($event->speakerlink))
		{
			tripleU("$uri#speaker", ns("foaf", "homepage"), $event->speakerlink);
		}
	}
}

?>
